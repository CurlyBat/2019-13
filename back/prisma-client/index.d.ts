// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  user: (where?: UserWhereInput) => Promise<boolean>;
  block: (where?: blockWhereInput) => Promise<boolean>;
  block_category: (where?: block_categoryWhereInput) => Promise<boolean>;
  block_type: (where?: block_typeWhereInput) => Promise<boolean>;
  project: (where?: projectWhereInput) => Promise<boolean>;
  project_auth: (where?: project_authWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  block: (where: blockWhereUniqueInput) => blockNullablePromise;
  blocks: (args?: {
    where?: blockWhereInput;
    orderBy?: blockOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<block>;
  blocksConnection: (args?: {
    where?: blockWhereInput;
    orderBy?: blockOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => blockConnectionPromise;
  blockCategory: (
    where: block_categoryWhereUniqueInput
  ) => block_categoryNullablePromise;
  blockCategories: (args?: {
    where?: block_categoryWhereInput;
    orderBy?: block_categoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<block_category>;
  blockCategoriesConnection: (args?: {
    where?: block_categoryWhereInput;
    orderBy?: block_categoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => block_categoryConnectionPromise;
  blockType: (where: block_typeWhereUniqueInput) => block_typeNullablePromise;
  blockTypes: (args?: {
    where?: block_typeWhereInput;
    orderBy?: block_typeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<block_type>;
  blockTypesConnection: (args?: {
    where?: block_typeWhereInput;
    orderBy?: block_typeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => block_typeConnectionPromise;
  project: (where: projectWhereUniqueInput) => projectNullablePromise;
  projects: (args?: {
    where?: projectWhereInput;
    orderBy?: projectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<project>;
  projectsConnection: (args?: {
    where?: projectWhereInput;
    orderBy?: projectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => projectConnectionPromise;
  projectAuth: (
    where: project_authWhereUniqueInput
  ) => project_authNullablePromise;
  projectAuths: (args?: {
    where?: project_authWhereInput;
    orderBy?: project_authOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<project_auth>;
  projectAuthsConnection: (args?: {
    where?: project_authWhereInput;
    orderBy?: project_authOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => project_authConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createblock: (data: blockCreateInput) => blockPromise;
  updateblock: (args: {
    data: blockUpdateInput;
    where: blockWhereUniqueInput;
  }) => blockPromise;
  updateManyblocks: (args: {
    data: blockUpdateManyMutationInput;
    where?: blockWhereInput;
  }) => BatchPayloadPromise;
  upsertblock: (args: {
    where: blockWhereUniqueInput;
    create: blockCreateInput;
    update: blockUpdateInput;
  }) => blockPromise;
  deleteblock: (where: blockWhereUniqueInput) => blockPromise;
  deleteManyblocks: (where?: blockWhereInput) => BatchPayloadPromise;
  createblock_category: (
    data: block_categoryCreateInput
  ) => block_categoryPromise;
  updateblock_category: (args: {
    data: block_categoryUpdateInput;
    where: block_categoryWhereUniqueInput;
  }) => block_categoryPromise;
  updateManyblock_categories: (args: {
    data: block_categoryUpdateManyMutationInput;
    where?: block_categoryWhereInput;
  }) => BatchPayloadPromise;
  upsertblock_category: (args: {
    where: block_categoryWhereUniqueInput;
    create: block_categoryCreateInput;
    update: block_categoryUpdateInput;
  }) => block_categoryPromise;
  deleteblock_category: (
    where: block_categoryWhereUniqueInput
  ) => block_categoryPromise;
  deleteManyblock_categories: (
    where?: block_categoryWhereInput
  ) => BatchPayloadPromise;
  createblock_type: (data: block_typeCreateInput) => block_typePromise;
  updateblock_type: (args: {
    data: block_typeUpdateInput;
    where: block_typeWhereUniqueInput;
  }) => block_typePromise;
  updateManyblock_types: (args: {
    data: block_typeUpdateManyMutationInput;
    where?: block_typeWhereInput;
  }) => BatchPayloadPromise;
  upsertblock_type: (args: {
    where: block_typeWhereUniqueInput;
    create: block_typeCreateInput;
    update: block_typeUpdateInput;
  }) => block_typePromise;
  deleteblock_type: (where: block_typeWhereUniqueInput) => block_typePromise;
  deleteManyblock_types: (where?: block_typeWhereInput) => BatchPayloadPromise;
  createproject: (data: projectCreateInput) => projectPromise;
  updateproject: (args: {
    data: projectUpdateInput;
    where: projectWhereUniqueInput;
  }) => projectPromise;
  updateManyprojects: (args: {
    data: projectUpdateManyMutationInput;
    where?: projectWhereInput;
  }) => BatchPayloadPromise;
  upsertproject: (args: {
    where: projectWhereUniqueInput;
    create: projectCreateInput;
    update: projectUpdateInput;
  }) => projectPromise;
  deleteproject: (where: projectWhereUniqueInput) => projectPromise;
  deleteManyprojects: (where?: projectWhereInput) => BatchPayloadPromise;
  createproject_auth: (data: project_authCreateInput) => project_authPromise;
  updateproject_auth: (args: {
    data: project_authUpdateInput;
    where: project_authWhereUniqueInput;
  }) => project_authPromise;
  upsertproject_auth: (args: {
    where: project_authWhereUniqueInput;
    create: project_authCreateInput;
    update: project_authUpdateInput;
  }) => project_authPromise;
  deleteproject_auth: (
    where: project_authWhereUniqueInput
  ) => project_authPromise;
  deleteManyproject_auths: (
    where?: project_authWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  block: (
    where?: blockSubscriptionWhereInput
  ) => blockSubscriptionPayloadSubscription;
  blockCategory: (
    where?: block_categorySubscriptionWhereInput
  ) => block_categorySubscriptionPayloadSubscription;
  blockType: (
    where?: block_typeSubscriptionWhereInput
  ) => block_typeSubscriptionPayloadSubscription;
  project: (
    where?: projectSubscriptionWhereInput
  ) => projectSubscriptionPayloadSubscription;
  projectAuth: (
    where?: project_authSubscriptionWhereInput
  ) => project_authSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type projectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "like_ASC"
  | "like_DESC"
  | "private_ASC"
  | "private_DESC";

export type blockOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "position_X_ASC"
  | "position_X_DESC"
  | "position_Y_ASC"
  | "position_Y_DESC"
  | "order_ASC"
  | "order_DESC";

export type block_typeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "shape_ASC"
  | "shape_DESC"
  | "content_ASC"
  | "content_DESC";

export type project_authOrderByInput = "id_ASC" | "id_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "picture_ASC"
  | "picture_DESC"
  | "email_ASC"
  | "email_DESC";

export type block_categoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "color_ASC"
  | "color_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface UserUpdateWithoutProjectsDataInput {
  name?: Maybe<String>;
  picture?: Maybe<String>;
  email?: Maybe<String>;
  authes?: Maybe<project_authUpdateManyWithoutUserInput>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface projectUpdateOneRequiredWithoutAuthesInput {
  create?: Maybe<projectCreateWithoutAuthesInput>;
  update?: Maybe<projectUpdateWithoutAuthesDataInput>;
  upsert?: Maybe<projectUpsertWithoutAuthesInput>;
  connect?: Maybe<projectWhereUniqueInput>;
}

export interface blockWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  position_X?: Maybe<Float>;
  position_X_not?: Maybe<Float>;
  position_X_in?: Maybe<Float[] | Float>;
  position_X_not_in?: Maybe<Float[] | Float>;
  position_X_lt?: Maybe<Float>;
  position_X_lte?: Maybe<Float>;
  position_X_gt?: Maybe<Float>;
  position_X_gte?: Maybe<Float>;
  position_Y?: Maybe<Float>;
  position_Y_not?: Maybe<Float>;
  position_Y_in?: Maybe<Float[] | Float>;
  position_Y_not_in?: Maybe<Float[] | Float>;
  position_Y_lt?: Maybe<Float>;
  position_Y_lte?: Maybe<Float>;
  position_Y_gt?: Maybe<Float>;
  position_Y_gte?: Maybe<Float>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  project?: Maybe<projectWhereInput>;
  parent?: Maybe<blockWhereInput>;
  type?: Maybe<block_typeWhereInput>;
  AND?: Maybe<blockWhereInput[] | blockWhereInput>;
  OR?: Maybe<blockWhereInput[] | blockWhereInput>;
  NOT?: Maybe<blockWhereInput[] | blockWhereInput>;
}

export interface projectUpdateWithoutAuthesDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  like?: Maybe<Int>;
  private?: Maybe<Boolean>;
  owner?: Maybe<UserUpdateOneRequiredWithoutProjectsInput>;
  blocks?: Maybe<blockUpdateManyWithoutProjectInput>;
}

export interface block_typeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  shape?: Maybe<String>;
  shape_not?: Maybe<String>;
  shape_in?: Maybe<String[] | String>;
  shape_not_in?: Maybe<String[] | String>;
  shape_lt?: Maybe<String>;
  shape_lte?: Maybe<String>;
  shape_gt?: Maybe<String>;
  shape_gte?: Maybe<String>;
  shape_contains?: Maybe<String>;
  shape_not_contains?: Maybe<String>;
  shape_starts_with?: Maybe<String>;
  shape_not_starts_with?: Maybe<String>;
  shape_ends_with?: Maybe<String>;
  shape_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  block_every?: Maybe<blockWhereInput>;
  block_some?: Maybe<blockWhereInput>;
  block_none?: Maybe<blockWhereInput>;
  block_category?: Maybe<block_categoryWhereInput>;
  AND?: Maybe<block_typeWhereInput[] | block_typeWhereInput>;
  OR?: Maybe<block_typeWhereInput[] | block_typeWhereInput>;
  NOT?: Maybe<block_typeWhereInput[] | block_typeWhereInput>;
}

export interface projectUpsertWithoutAuthesInput {
  update: projectUpdateWithoutAuthesDataInput;
  create: projectCreateWithoutAuthesInput;
}

export interface project_authWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  project?: Maybe<projectWhereInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<project_authWhereInput[] | project_authWhereInput>;
  OR?: Maybe<project_authWhereInput[] | project_authWhereInput>;
  NOT?: Maybe<project_authWhereInput[] | project_authWhereInput>;
}

export interface project_authUpsertWithWhereUniqueWithoutUserInput {
  where: project_authWhereUniqueInput;
  update: project_authUpdateWithoutUserDataInput;
  create: project_authCreateWithoutUserInput;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  picture?: Maybe<String>;
  picture_not?: Maybe<String>;
  picture_in?: Maybe<String[] | String>;
  picture_not_in?: Maybe<String[] | String>;
  picture_lt?: Maybe<String>;
  picture_lte?: Maybe<String>;
  picture_gt?: Maybe<String>;
  picture_gte?: Maybe<String>;
  picture_contains?: Maybe<String>;
  picture_not_contains?: Maybe<String>;
  picture_starts_with?: Maybe<String>;
  picture_not_starts_with?: Maybe<String>;
  picture_ends_with?: Maybe<String>;
  picture_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  projects_every?: Maybe<projectWhereInput>;
  projects_some?: Maybe<projectWhereInput>;
  projects_none?: Maybe<projectWhereInput>;
  authes_every?: Maybe<project_authWhereInput>;
  authes_some?: Maybe<project_authWhereInput>;
  authes_none?: Maybe<project_authWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface block_categoryCreateWithoutBlock_typesInput {
  id?: Maybe<ID_Input>;
  text?: Maybe<String>;
  color?: Maybe<String>;
}

export interface block_typeCreateManyWithoutBlock_categoryInput {
  create?: Maybe<
    | block_typeCreateWithoutBlock_categoryInput[]
    | block_typeCreateWithoutBlock_categoryInput
  >;
  connect?: Maybe<block_typeWhereUniqueInput[] | block_typeWhereUniqueInput>;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
  picture?: Maybe<String>;
  email?: Maybe<String>;
  projects?: Maybe<projectUpdateManyWithoutOwnerInput>;
  authes?: Maybe<project_authUpdateManyWithoutUserInput>;
}

export interface project_authScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  AND?: Maybe<project_authScalarWhereInput[] | project_authScalarWhereInput>;
  OR?: Maybe<project_authScalarWhereInput[] | project_authScalarWhereInput>;
  NOT?: Maybe<project_authScalarWhereInput[] | project_authScalarWhereInput>;
}

export interface projectUpdateManyWithoutOwnerInput {
  create?: Maybe<
    projectCreateWithoutOwnerInput[] | projectCreateWithoutOwnerInput
  >;
  delete?: Maybe<projectWhereUniqueInput[] | projectWhereUniqueInput>;
  connect?: Maybe<projectWhereUniqueInput[] | projectWhereUniqueInput>;
  set?: Maybe<projectWhereUniqueInput[] | projectWhereUniqueInput>;
  disconnect?: Maybe<projectWhereUniqueInput[] | projectWhereUniqueInput>;
  update?: Maybe<
    | projectUpdateWithWhereUniqueWithoutOwnerInput[]
    | projectUpdateWithWhereUniqueWithoutOwnerInput
  >;
  upsert?: Maybe<
    | projectUpsertWithWhereUniqueWithoutOwnerInput[]
    | projectUpsertWithWhereUniqueWithoutOwnerInput
  >;
  deleteMany?: Maybe<projectScalarWhereInput[] | projectScalarWhereInput>;
  updateMany?: Maybe<
    | projectUpdateManyWithWhereNestedInput[]
    | projectUpdateManyWithWhereNestedInput
  >;
}

export interface projectSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<projectWhereInput>;
  AND?: Maybe<projectSubscriptionWhereInput[] | projectSubscriptionWhereInput>;
  OR?: Maybe<projectSubscriptionWhereInput[] | projectSubscriptionWhereInput>;
  NOT?: Maybe<projectSubscriptionWhereInput[] | projectSubscriptionWhereInput>;
}

export interface projectUpdateWithWhereUniqueWithoutOwnerInput {
  where: projectWhereUniqueInput;
  data: projectUpdateWithoutOwnerDataInput;
}

export interface projectWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  like?: Maybe<Int>;
  like_not?: Maybe<Int>;
  like_in?: Maybe<Int[] | Int>;
  like_not_in?: Maybe<Int[] | Int>;
  like_lt?: Maybe<Int>;
  like_lte?: Maybe<Int>;
  like_gt?: Maybe<Int>;
  like_gte?: Maybe<Int>;
  private?: Maybe<Boolean>;
  private_not?: Maybe<Boolean>;
  owner?: Maybe<UserWhereInput>;
  blocks_every?: Maybe<blockWhereInput>;
  blocks_some?: Maybe<blockWhereInput>;
  blocks_none?: Maybe<blockWhereInput>;
  authes_every?: Maybe<project_authWhereInput>;
  authes_some?: Maybe<project_authWhereInput>;
  authes_none?: Maybe<project_authWhereInput>;
  AND?: Maybe<projectWhereInput[] | projectWhereInput>;
  OR?: Maybe<projectWhereInput[] | projectWhereInput>;
  NOT?: Maybe<projectWhereInput[] | projectWhereInput>;
}

export interface projectUpdateWithoutOwnerDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  like?: Maybe<Int>;
  private?: Maybe<Boolean>;
  blocks?: Maybe<blockUpdateManyWithoutProjectInput>;
  authes?: Maybe<project_authUpdateManyWithoutProjectInput>;
}

export interface blockSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<blockWhereInput>;
  AND?: Maybe<blockSubscriptionWhereInput[] | blockSubscriptionWhereInput>;
  OR?: Maybe<blockSubscriptionWhereInput[] | blockSubscriptionWhereInput>;
  NOT?: Maybe<blockSubscriptionWhereInput[] | blockSubscriptionWhereInput>;
}

export interface blockUpdateManyWithoutProjectInput {
  create?: Maybe<
    blockCreateWithoutProjectInput[] | blockCreateWithoutProjectInput
  >;
  delete?: Maybe<blockWhereUniqueInput[] | blockWhereUniqueInput>;
  connect?: Maybe<blockWhereUniqueInput[] | blockWhereUniqueInput>;
  set?: Maybe<blockWhereUniqueInput[] | blockWhereUniqueInput>;
  disconnect?: Maybe<blockWhereUniqueInput[] | blockWhereUniqueInput>;
  update?: Maybe<
    | blockUpdateWithWhereUniqueWithoutProjectInput[]
    | blockUpdateWithWhereUniqueWithoutProjectInput
  >;
  upsert?: Maybe<
    | blockUpsertWithWhereUniqueWithoutProjectInput[]
    | blockUpsertWithWhereUniqueWithoutProjectInput
  >;
  deleteMany?: Maybe<blockScalarWhereInput[] | blockScalarWhereInput>;
  updateMany?: Maybe<
    blockUpdateManyWithWhereNestedInput[] | blockUpdateManyWithWhereNestedInput
  >;
}

export interface project_authUpdateInput {
  project?: Maybe<projectUpdateOneRequiredWithoutAuthesInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutAuthesInput>;
}

export interface blockUpdateWithWhereUniqueWithoutProjectInput {
  where: blockWhereUniqueInput;
  data: blockUpdateWithoutProjectDataInput;
}

export interface project_authCreateInput {
  id?: Maybe<ID_Input>;
  project: projectCreateOneWithoutAuthesInput;
  user: UserCreateOneWithoutAuthesInput;
}

export interface blockUpdateWithoutProjectDataInput {
  position_X?: Maybe<Float>;
  position_Y?: Maybe<Float>;
  order?: Maybe<Int>;
  parent?: Maybe<blockUpdateOneWithoutParentInput>;
  type?: Maybe<block_typeUpdateOneRequiredWithoutBlockInput>;
}

export interface projectUpdateInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  like?: Maybe<Int>;
  private?: Maybe<Boolean>;
  owner?: Maybe<UserUpdateOneRequiredWithoutProjectsInput>;
  blocks?: Maybe<blockUpdateManyWithoutProjectInput>;
  authes?: Maybe<project_authUpdateManyWithoutProjectInput>;
}

export interface blockUpdateOneWithoutParentInput {
  create?: Maybe<blockCreateWithoutParentInput>;
  update?: Maybe<blockUpdateWithoutParentDataInput>;
  upsert?: Maybe<blockUpsertWithoutParentInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<blockWhereUniqueInput>;
}

export interface projectCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  like: Int;
  private: Boolean;
  owner: UserCreateOneWithoutProjectsInput;
  blocks?: Maybe<blockCreateManyWithoutProjectInput>;
  authes?: Maybe<project_authCreateManyWithoutProjectInput>;
}

export interface blockUpdateWithoutParentDataInput {
  position_X?: Maybe<Float>;
  position_Y?: Maybe<Float>;
  order?: Maybe<Int>;
  project?: Maybe<projectUpdateOneRequiredWithoutBlocksInput>;
  type?: Maybe<block_typeUpdateOneRequiredWithoutBlockInput>;
}

export interface block_typeUpdateInput {
  name?: Maybe<String>;
  shape?: Maybe<String>;
  content?: Maybe<String>;
  block?: Maybe<blockUpdateManyWithoutTypeInput>;
  block_category?: Maybe<
    block_categoryUpdateOneRequiredWithoutBlock_typesInput
  >;
}

export interface projectUpdateOneRequiredWithoutBlocksInput {
  create?: Maybe<projectCreateWithoutBlocksInput>;
  update?: Maybe<projectUpdateWithoutBlocksDataInput>;
  upsert?: Maybe<projectUpsertWithoutBlocksInput>;
  connect?: Maybe<projectWhereUniqueInput>;
}

export type block_typeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface projectUpdateWithoutBlocksDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  like?: Maybe<Int>;
  private?: Maybe<Boolean>;
  owner?: Maybe<UserUpdateOneRequiredWithoutProjectsInput>;
  authes?: Maybe<project_authUpdateManyWithoutProjectInput>;
}

export interface block_typeUpdateManyDataInput {
  name?: Maybe<String>;
  shape?: Maybe<String>;
  content?: Maybe<String>;
}

export interface UserUpdateOneRequiredWithoutProjectsInput {
  create?: Maybe<UserCreateWithoutProjectsInput>;
  update?: Maybe<UserUpdateWithoutProjectsDataInput>;
  upsert?: Maybe<UserUpsertWithoutProjectsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export type projectWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface block_typeUpdateWithoutBlock_categoryDataInput {
  name?: Maybe<String>;
  shape?: Maybe<String>;
  content?: Maybe<String>;
  block?: Maybe<blockUpdateManyWithoutTypeInput>;
}

export interface block_typeUpsertWithWhereUniqueWithoutBlock_categoryInput {
  where: block_typeWhereUniqueInput;
  update: block_typeUpdateWithoutBlock_categoryDataInput;
  create: block_typeCreateWithoutBlock_categoryInput;
}

export interface project_authUpdateManyWithoutUserInput {
  create?: Maybe<
    project_authCreateWithoutUserInput[] | project_authCreateWithoutUserInput
  >;
  delete?: Maybe<project_authWhereUniqueInput[] | project_authWhereUniqueInput>;
  connect?: Maybe<
    project_authWhereUniqueInput[] | project_authWhereUniqueInput
  >;
  set?: Maybe<project_authWhereUniqueInput[] | project_authWhereUniqueInput>;
  disconnect?: Maybe<
    project_authWhereUniqueInput[] | project_authWhereUniqueInput
  >;
  update?: Maybe<
    | project_authUpdateWithWhereUniqueWithoutUserInput[]
    | project_authUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | project_authUpsertWithWhereUniqueWithoutUserInput[]
    | project_authUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    project_authScalarWhereInput[] | project_authScalarWhereInput
  >;
}

export type project_authWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface project_authUpdateWithWhereUniqueWithoutUserInput {
  where: project_authWhereUniqueInput;
  data: project_authUpdateWithoutUserDataInput;
}

export interface blockUpdateWithWhereUniqueWithoutTypeInput {
  where: blockWhereUniqueInput;
  data: blockUpdateWithoutTypeDataInput;
}

export interface project_authUpdateWithoutUserDataInput {
  project?: Maybe<projectUpdateOneRequiredWithoutAuthesInput>;
}

export interface projectCreateManyWithoutOwnerInput {
  create?: Maybe<
    projectCreateWithoutOwnerInput[] | projectCreateWithoutOwnerInput
  >;
  connect?: Maybe<projectWhereUniqueInput[] | projectWhereUniqueInput>;
}

export interface block_typeUpdateWithWhereUniqueWithoutBlock_categoryInput {
  where: block_typeWhereUniqueInput;
  data: block_typeUpdateWithoutBlock_categoryDataInput;
}

export interface blockCreateManyWithoutProjectInput {
  create?: Maybe<
    blockCreateWithoutProjectInput[] | blockCreateWithoutProjectInput
  >;
  connect?: Maybe<blockWhereUniqueInput[] | blockWhereUniqueInput>;
}

export interface block_categoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  color?: Maybe<String>;
  color_not?: Maybe<String>;
  color_in?: Maybe<String[] | String>;
  color_not_in?: Maybe<String[] | String>;
  color_lt?: Maybe<String>;
  color_lte?: Maybe<String>;
  color_gt?: Maybe<String>;
  color_gte?: Maybe<String>;
  color_contains?: Maybe<String>;
  color_not_contains?: Maybe<String>;
  color_starts_with?: Maybe<String>;
  color_not_starts_with?: Maybe<String>;
  color_ends_with?: Maybe<String>;
  color_not_ends_with?: Maybe<String>;
  block_types_every?: Maybe<block_typeWhereInput>;
  block_types_some?: Maybe<block_typeWhereInput>;
  block_types_none?: Maybe<block_typeWhereInput>;
  AND?: Maybe<block_categoryWhereInput[] | block_categoryWhereInput>;
  OR?: Maybe<block_categoryWhereInput[] | block_categoryWhereInput>;
  NOT?: Maybe<block_categoryWhereInput[] | block_categoryWhereInput>;
}

export interface blockCreateOneWithoutParentInput {
  create?: Maybe<blockCreateWithoutParentInput>;
  connect?: Maybe<blockWhereUniqueInput>;
}

export interface block_typeUpdateManyWithoutBlock_categoryInput {
  create?: Maybe<
    | block_typeCreateWithoutBlock_categoryInput[]
    | block_typeCreateWithoutBlock_categoryInput
  >;
  delete?: Maybe<block_typeWhereUniqueInput[] | block_typeWhereUniqueInput>;
  connect?: Maybe<block_typeWhereUniqueInput[] | block_typeWhereUniqueInput>;
  set?: Maybe<block_typeWhereUniqueInput[] | block_typeWhereUniqueInput>;
  disconnect?: Maybe<block_typeWhereUniqueInput[] | block_typeWhereUniqueInput>;
  update?: Maybe<
    | block_typeUpdateWithWhereUniqueWithoutBlock_categoryInput[]
    | block_typeUpdateWithWhereUniqueWithoutBlock_categoryInput
  >;
  upsert?: Maybe<
    | block_typeUpsertWithWhereUniqueWithoutBlock_categoryInput[]
    | block_typeUpsertWithWhereUniqueWithoutBlock_categoryInput
  >;
  deleteMany?: Maybe<block_typeScalarWhereInput[] | block_typeScalarWhereInput>;
  updateMany?: Maybe<
    | block_typeUpdateManyWithWhereNestedInput[]
    | block_typeUpdateManyWithWhereNestedInput
  >;
}

export interface projectCreateOneWithoutBlocksInput {
  create?: Maybe<projectCreateWithoutBlocksInput>;
  connect?: Maybe<projectWhereUniqueInput>;
}

export interface block_categoryUpdateInput {
  text?: Maybe<String>;
  color?: Maybe<String>;
  block_types?: Maybe<block_typeUpdateManyWithoutBlock_categoryInput>;
}

export interface UserCreateOneWithoutProjectsInput {
  create?: Maybe<UserCreateWithoutProjectsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface blockCreateWithoutTypeInput {
  id?: Maybe<ID_Input>;
  position_X?: Maybe<Float>;
  position_Y?: Maybe<Float>;
  order: Int;
  project: projectCreateOneWithoutBlocksInput;
  parent?: Maybe<blockCreateOneWithoutParentInput>;
}

export interface project_authCreateManyWithoutUserInput {
  create?: Maybe<
    project_authCreateWithoutUserInput[] | project_authCreateWithoutUserInput
  >;
  connect?: Maybe<
    project_authWhereUniqueInput[] | project_authWhereUniqueInput
  >;
}

export interface UserUpsertWithoutProjectsInput {
  update: UserUpdateWithoutProjectsDataInput;
  create: UserCreateWithoutProjectsInput;
}

export interface projectCreateOneWithoutAuthesInput {
  create?: Maybe<projectCreateWithoutAuthesInput>;
  connect?: Maybe<projectWhereUniqueInput>;
}

export interface project_authUpdateManyWithoutProjectInput {
  create?: Maybe<
    | project_authCreateWithoutProjectInput[]
    | project_authCreateWithoutProjectInput
  >;
  delete?: Maybe<project_authWhereUniqueInput[] | project_authWhereUniqueInput>;
  connect?: Maybe<
    project_authWhereUniqueInput[] | project_authWhereUniqueInput
  >;
  set?: Maybe<project_authWhereUniqueInput[] | project_authWhereUniqueInput>;
  disconnect?: Maybe<
    project_authWhereUniqueInput[] | project_authWhereUniqueInput
  >;
  update?: Maybe<
    | project_authUpdateWithWhereUniqueWithoutProjectInput[]
    | project_authUpdateWithWhereUniqueWithoutProjectInput
  >;
  upsert?: Maybe<
    | project_authUpsertWithWhereUniqueWithoutProjectInput[]
    | project_authUpsertWithWhereUniqueWithoutProjectInput
  >;
  deleteMany?: Maybe<
    project_authScalarWhereInput[] | project_authScalarWhereInput
  >;
}

export interface project_authCreateManyWithoutProjectInput {
  create?: Maybe<
    | project_authCreateWithoutProjectInput[]
    | project_authCreateWithoutProjectInput
  >;
  connect?: Maybe<
    project_authWhereUniqueInput[] | project_authWhereUniqueInput
  >;
}

export interface project_authUpdateWithWhereUniqueWithoutProjectInput {
  where: project_authWhereUniqueInput;
  data: project_authUpdateWithoutProjectDataInput;
}

export interface UserCreateOneWithoutAuthesInput {
  create?: Maybe<UserCreateWithoutAuthesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface project_authUpdateWithoutProjectDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutAuthesInput>;
}

export interface block_typeCreateOneWithoutBlockInput {
  create?: Maybe<block_typeCreateWithoutBlockInput>;
  connect?: Maybe<block_typeWhereUniqueInput>;
}

export interface UserUpdateOneRequiredWithoutAuthesInput {
  create?: Maybe<UserCreateWithoutAuthesInput>;
  update?: Maybe<UserUpdateWithoutAuthesDataInput>;
  upsert?: Maybe<UserUpsertWithoutAuthesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface block_categoryCreateOneWithoutBlock_typesInput {
  create?: Maybe<block_categoryCreateWithoutBlock_typesInput>;
  connect?: Maybe<block_categoryWhereUniqueInput>;
}

export interface UserUpdateWithoutAuthesDataInput {
  name?: Maybe<String>;
  picture?: Maybe<String>;
  email?: Maybe<String>;
  projects?: Maybe<projectUpdateManyWithoutOwnerInput>;
}

export interface block_typeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<block_typeWhereInput>;
  AND?: Maybe<
    block_typeSubscriptionWhereInput[] | block_typeSubscriptionWhereInput
  >;
  OR?: Maybe<
    block_typeSubscriptionWhereInput[] | block_typeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    block_typeSubscriptionWhereInput[] | block_typeSubscriptionWhereInput
  >;
}

export interface UserUpsertWithoutAuthesInput {
  update: UserUpdateWithoutAuthesDataInput;
  create: UserCreateWithoutAuthesInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface project_authUpsertWithWhereUniqueWithoutProjectInput {
  where: project_authWhereUniqueInput;
  update: project_authUpdateWithoutProjectDataInput;
  create: project_authCreateWithoutProjectInput;
}

export interface projectUpdateManyMutationInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  like?: Maybe<Int>;
  private?: Maybe<Boolean>;
}

export interface projectUpsertWithoutBlocksInput {
  update: projectUpdateWithoutBlocksDataInput;
  create: projectCreateWithoutBlocksInput;
}

export interface block_typeUpdateManyMutationInput {
  name?: Maybe<String>;
  shape?: Maybe<String>;
  content?: Maybe<String>;
}

export interface block_typeUpdateOneRequiredWithoutBlockInput {
  create?: Maybe<block_typeCreateWithoutBlockInput>;
  update?: Maybe<block_typeUpdateWithoutBlockDataInput>;
  upsert?: Maybe<block_typeUpsertWithoutBlockInput>;
  connect?: Maybe<block_typeWhereUniqueInput>;
}

export interface block_categoryUpdateManyMutationInput {
  text?: Maybe<String>;
  color?: Maybe<String>;
}

export interface block_typeUpdateWithoutBlockDataInput {
  name?: Maybe<String>;
  shape?: Maybe<String>;
  content?: Maybe<String>;
  block_category?: Maybe<
    block_categoryUpdateOneRequiredWithoutBlock_typesInput
  >;
}

export interface block_typeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  shape?: Maybe<String>;
  shape_not?: Maybe<String>;
  shape_in?: Maybe<String[] | String>;
  shape_not_in?: Maybe<String[] | String>;
  shape_lt?: Maybe<String>;
  shape_lte?: Maybe<String>;
  shape_gt?: Maybe<String>;
  shape_gte?: Maybe<String>;
  shape_contains?: Maybe<String>;
  shape_not_contains?: Maybe<String>;
  shape_starts_with?: Maybe<String>;
  shape_not_starts_with?: Maybe<String>;
  shape_ends_with?: Maybe<String>;
  shape_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  AND?: Maybe<block_typeScalarWhereInput[] | block_typeScalarWhereInput>;
  OR?: Maybe<block_typeScalarWhereInput[] | block_typeScalarWhereInput>;
  NOT?: Maybe<block_typeScalarWhereInput[] | block_typeScalarWhereInput>;
}

export interface block_categoryUpdateOneRequiredWithoutBlock_typesInput {
  create?: Maybe<block_categoryCreateWithoutBlock_typesInput>;
  update?: Maybe<block_categoryUpdateWithoutBlock_typesDataInput>;
  upsert?: Maybe<block_categoryUpsertWithoutBlock_typesInput>;
  connect?: Maybe<block_categoryWhereUniqueInput>;
}

export interface blockUpdateWithoutTypeDataInput {
  position_X?: Maybe<Float>;
  position_Y?: Maybe<Float>;
  order?: Maybe<Int>;
  project?: Maybe<projectUpdateOneRequiredWithoutBlocksInput>;
  parent?: Maybe<blockUpdateOneWithoutParentInput>;
}

export interface block_categoryUpdateWithoutBlock_typesDataInput {
  text?: Maybe<String>;
  color?: Maybe<String>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  picture: String;
  email: String;
  projects?: Maybe<projectCreateManyWithoutOwnerInput>;
  authes?: Maybe<project_authCreateManyWithoutUserInput>;
}

export interface block_categoryUpsertWithoutBlock_typesInput {
  update: block_categoryUpdateWithoutBlock_typesDataInput;
  create: block_categoryCreateWithoutBlock_typesInput;
}

export interface blockCreateWithoutProjectInput {
  id?: Maybe<ID_Input>;
  position_X?: Maybe<Float>;
  position_Y?: Maybe<Float>;
  order: Int;
  parent?: Maybe<blockCreateOneWithoutParentInput>;
  type: block_typeCreateOneWithoutBlockInput;
}

export interface block_typeUpsertWithoutBlockInput {
  update: block_typeUpdateWithoutBlockDataInput;
  create: block_typeCreateWithoutBlockInput;
}

export interface projectCreateWithoutBlocksInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  like: Int;
  private: Boolean;
  owner: UserCreateOneWithoutProjectsInput;
  authes?: Maybe<project_authCreateManyWithoutProjectInput>;
}

export interface blockUpsertWithoutParentInput {
  update: blockUpdateWithoutParentDataInput;
  create: blockCreateWithoutParentInput;
}

export interface project_authCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  project: projectCreateOneWithoutAuthesInput;
}

export interface blockUpsertWithWhereUniqueWithoutProjectInput {
  where: blockWhereUniqueInput;
  update: blockUpdateWithoutProjectDataInput;
  create: blockCreateWithoutProjectInput;
}

export interface project_authCreateWithoutProjectInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutAuthesInput;
}

export interface blockScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  position_X?: Maybe<Float>;
  position_X_not?: Maybe<Float>;
  position_X_in?: Maybe<Float[] | Float>;
  position_X_not_in?: Maybe<Float[] | Float>;
  position_X_lt?: Maybe<Float>;
  position_X_lte?: Maybe<Float>;
  position_X_gt?: Maybe<Float>;
  position_X_gte?: Maybe<Float>;
  position_Y?: Maybe<Float>;
  position_Y_not?: Maybe<Float>;
  position_Y_in?: Maybe<Float[] | Float>;
  position_Y_not_in?: Maybe<Float[] | Float>;
  position_Y_lt?: Maybe<Float>;
  position_Y_lte?: Maybe<Float>;
  position_Y_gt?: Maybe<Float>;
  position_Y_gte?: Maybe<Float>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  AND?: Maybe<blockScalarWhereInput[] | blockScalarWhereInput>;
  OR?: Maybe<blockScalarWhereInput[] | blockScalarWhereInput>;
  NOT?: Maybe<blockScalarWhereInput[] | blockScalarWhereInput>;
}

export interface block_typeCreateWithoutBlockInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  shape?: Maybe<String>;
  content?: Maybe<String>;
  block_category: block_categoryCreateOneWithoutBlock_typesInput;
}

export interface blockUpdateManyWithWhereNestedInput {
  where: blockScalarWhereInput;
  data: blockUpdateManyDataInput;
}

export interface block_categorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<block_categoryWhereInput>;
  AND?: Maybe<
    | block_categorySubscriptionWhereInput[]
    | block_categorySubscriptionWhereInput
  >;
  OR?: Maybe<
    | block_categorySubscriptionWhereInput[]
    | block_categorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | block_categorySubscriptionWhereInput[]
    | block_categorySubscriptionWhereInput
  >;
}

export interface blockUpdateManyDataInput {
  position_X?: Maybe<Float>;
  position_Y?: Maybe<Float>;
  order?: Maybe<Int>;
}

export type block_categoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  text?: Maybe<String>;
}>;

export interface projectUpsertWithWhereUniqueWithoutOwnerInput {
  where: projectWhereUniqueInput;
  update: projectUpdateWithoutOwnerDataInput;
  create: projectCreateWithoutOwnerInput;
}

export interface block_typeUpdateManyWithWhereNestedInput {
  where: block_typeScalarWhereInput;
  data: block_typeUpdateManyDataInput;
}

export interface projectScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  like?: Maybe<Int>;
  like_not?: Maybe<Int>;
  like_in?: Maybe<Int[] | Int>;
  like_not_in?: Maybe<Int[] | Int>;
  like_lt?: Maybe<Int>;
  like_lte?: Maybe<Int>;
  like_gt?: Maybe<Int>;
  like_gte?: Maybe<Int>;
  private?: Maybe<Boolean>;
  private_not?: Maybe<Boolean>;
  AND?: Maybe<projectScalarWhereInput[] | projectScalarWhereInput>;
  OR?: Maybe<projectScalarWhereInput[] | projectScalarWhereInput>;
  NOT?: Maybe<projectScalarWhereInput[] | projectScalarWhereInput>;
}

export interface blockUpdateManyWithoutTypeInput {
  create?: Maybe<blockCreateWithoutTypeInput[] | blockCreateWithoutTypeInput>;
  delete?: Maybe<blockWhereUniqueInput[] | blockWhereUniqueInput>;
  connect?: Maybe<blockWhereUniqueInput[] | blockWhereUniqueInput>;
  set?: Maybe<blockWhereUniqueInput[] | blockWhereUniqueInput>;
  disconnect?: Maybe<blockWhereUniqueInput[] | blockWhereUniqueInput>;
  update?: Maybe<
    | blockUpdateWithWhereUniqueWithoutTypeInput[]
    | blockUpdateWithWhereUniqueWithoutTypeInput
  >;
  upsert?: Maybe<
    | blockUpsertWithWhereUniqueWithoutTypeInput[]
    | blockUpsertWithWhereUniqueWithoutTypeInput
  >;
  deleteMany?: Maybe<blockScalarWhereInput[] | blockScalarWhereInput>;
  updateMany?: Maybe<
    blockUpdateManyWithWhereNestedInput[] | blockUpdateManyWithWhereNestedInput
  >;
}

export interface projectUpdateManyWithWhereNestedInput {
  where: projectScalarWhereInput;
  data: projectUpdateManyDataInput;
}

export interface blockCreateWithoutParentInput {
  id?: Maybe<ID_Input>;
  position_X?: Maybe<Float>;
  position_Y?: Maybe<Float>;
  order: Int;
  project: projectCreateOneWithoutBlocksInput;
  type: block_typeCreateOneWithoutBlockInput;
}

export interface projectUpdateManyDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  like?: Maybe<Int>;
  private?: Maybe<Boolean>;
}

export interface projectCreateWithoutAuthesInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  like: Int;
  private: Boolean;
  owner: UserCreateOneWithoutProjectsInput;
  blocks?: Maybe<blockCreateManyWithoutProjectInput>;
}

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  picture?: Maybe<String>;
  email?: Maybe<String>;
}

export interface project_authSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<project_authWhereInput>;
  AND?: Maybe<
    project_authSubscriptionWhereInput[] | project_authSubscriptionWhereInput
  >;
  OR?: Maybe<
    project_authSubscriptionWhereInput[] | project_authSubscriptionWhereInput
  >;
  NOT?: Maybe<
    project_authSubscriptionWhereInput[] | project_authSubscriptionWhereInput
  >;
}

export interface blockCreateManyWithoutTypeInput {
  create?: Maybe<blockCreateWithoutTypeInput[] | blockCreateWithoutTypeInput>;
  connect?: Maybe<blockWhereUniqueInput[] | blockWhereUniqueInput>;
}

export interface block_typeCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  shape?: Maybe<String>;
  content?: Maybe<String>;
  block?: Maybe<blockCreateManyWithoutTypeInput>;
  block_category: block_categoryCreateOneWithoutBlock_typesInput;
}

export interface block_typeCreateWithoutBlock_categoryInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  shape?: Maybe<String>;
  content?: Maybe<String>;
  block?: Maybe<blockCreateManyWithoutTypeInput>;
}

export interface projectCreateWithoutOwnerInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  like: Int;
  private: Boolean;
  blocks?: Maybe<blockCreateManyWithoutProjectInput>;
  authes?: Maybe<project_authCreateManyWithoutProjectInput>;
}

export interface block_categoryCreateInput {
  id?: Maybe<ID_Input>;
  text?: Maybe<String>;
  color?: Maybe<String>;
  block_types?: Maybe<block_typeCreateManyWithoutBlock_categoryInput>;
}

export interface blockUpdateManyMutationInput {
  position_X?: Maybe<Float>;
  position_Y?: Maybe<Float>;
  order?: Maybe<Int>;
}

export interface blockUpdateInput {
  position_X?: Maybe<Float>;
  position_Y?: Maybe<Float>;
  order?: Maybe<Int>;
  project?: Maybe<projectUpdateOneRequiredWithoutBlocksInput>;
  parent?: Maybe<blockUpdateOneWithoutParentInput>;
  type?: Maybe<block_typeUpdateOneRequiredWithoutBlockInput>;
}

export interface blockCreateInput {
  id?: Maybe<ID_Input>;
  position_X?: Maybe<Float>;
  position_Y?: Maybe<Float>;
  order: Int;
  project: projectCreateOneWithoutBlocksInput;
  parent?: Maybe<blockCreateOneWithoutParentInput>;
  type: block_typeCreateOneWithoutBlockInput;
}

export interface UserCreateWithoutProjectsInput {
  id?: Maybe<ID_Input>;
  name: String;
  picture: String;
  email: String;
  authes?: Maybe<project_authCreateManyWithoutUserInput>;
}

export interface blockUpsertWithWhereUniqueWithoutTypeInput {
  where: blockWhereUniqueInput;
  update: blockUpdateWithoutTypeDataInput;
  create: blockCreateWithoutTypeInput;
}

export type blockWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserCreateWithoutAuthesInput {
  id?: Maybe<ID_Input>;
  name: String;
  picture: String;
  email: String;
  projects?: Maybe<projectCreateManyWithoutOwnerInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface project_authPreviousValues {
  id: ID_Output;
}

export interface project_authPreviousValuesPromise
  extends Promise<project_authPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface project_authPreviousValuesSubscription
  extends Promise<AsyncIterator<project_authPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface blockEdge {
  node: block;
  cursor: String;
}

export interface blockEdgePromise extends Promise<blockEdge>, Fragmentable {
  node: <T = blockPromise>() => T;
  cursor: () => Promise<String>;
}

export interface blockEdgeSubscription
  extends Promise<AsyncIterator<blockEdge>>,
    Fragmentable {
  node: <T = blockSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface block_type {
  id: ID_Output;
  name?: String;
  shape?: String;
  content?: String;
}

export interface block_typePromise extends Promise<block_type>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  shape: () => Promise<String>;
  content: () => Promise<String>;
  block: <T = FragmentableArray<block>>(args?: {
    where?: blockWhereInput;
    orderBy?: blockOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  block_category: <T = block_categoryPromise>() => T;
}

export interface block_typeSubscription
  extends Promise<AsyncIterator<block_type>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  shape: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  block: <T = Promise<AsyncIterator<blockSubscription>>>(args?: {
    where?: blockWhereInput;
    orderBy?: blockOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  block_category: <T = block_categorySubscription>() => T;
}

export interface block_typeNullablePromise
  extends Promise<block_type | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  shape: () => Promise<String>;
  content: () => Promise<String>;
  block: <T = FragmentableArray<block>>(args?: {
    where?: blockWhereInput;
    orderBy?: blockOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  block_category: <T = block_categoryPromise>() => T;
}

export interface blockConnection {
  pageInfo: PageInfo;
  edges: blockEdge[];
}

export interface blockConnectionPromise
  extends Promise<blockConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<blockEdge>>() => T;
  aggregate: <T = AggregateblockPromise>() => T;
}

export interface blockConnectionSubscription
  extends Promise<AsyncIterator<blockConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<blockEdgeSubscription>>>() => T;
  aggregate: <T = AggregateblockSubscription>() => T;
}

export interface block_category {
  id: ID_Output;
  text?: String;
  color?: String;
}

export interface block_categoryPromise
  extends Promise<block_category>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  color: () => Promise<String>;
  block_types: <T = FragmentableArray<block_type>>(args?: {
    where?: block_typeWhereInput;
    orderBy?: block_typeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface block_categorySubscription
  extends Promise<AsyncIterator<block_category>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  color: () => Promise<AsyncIterator<String>>;
  block_types: <T = Promise<AsyncIterator<block_typeSubscription>>>(args?: {
    where?: block_typeWhereInput;
    orderBy?: block_typeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface block_categoryNullablePromise
  extends Promise<block_category | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  color: () => Promise<String>;
  block_types: <T = FragmentableArray<block_type>>(args?: {
    where?: block_typeWhereInput;
    orderBy?: block_typeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface project {
  id: ID_Output;
  title: String;
  description: String;
  like: Int;
  private: Boolean;
}

export interface projectPromise extends Promise<project>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  like: () => Promise<Int>;
  private: () => Promise<Boolean>;
  owner: <T = UserPromise>() => T;
  blocks: <T = FragmentableArray<block>>(args?: {
    where?: blockWhereInput;
    orderBy?: blockOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  authes: <T = FragmentableArray<project_auth>>(args?: {
    where?: project_authWhereInput;
    orderBy?: project_authOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface projectSubscription
  extends Promise<AsyncIterator<project>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  like: () => Promise<AsyncIterator<Int>>;
  private: () => Promise<AsyncIterator<Boolean>>;
  owner: <T = UserSubscription>() => T;
  blocks: <T = Promise<AsyncIterator<blockSubscription>>>(args?: {
    where?: blockWhereInput;
    orderBy?: blockOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  authes: <T = Promise<AsyncIterator<project_authSubscription>>>(args?: {
    where?: project_authWhereInput;
    orderBy?: project_authOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface projectNullablePromise
  extends Promise<project | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  like: () => Promise<Int>;
  private: () => Promise<Boolean>;
  owner: <T = UserPromise>() => T;
  blocks: <T = FragmentableArray<block>>(args?: {
    where?: blockWhereInput;
    orderBy?: blockOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  authes: <T = FragmentableArray<project_auth>>(args?: {
    where?: project_authWhereInput;
    orderBy?: project_authOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface block {
  id: ID_Output;
  position_X?: Float;
  position_Y?: Float;
  order: Int;
}

export interface blockPromise extends Promise<block>, Fragmentable {
  id: () => Promise<ID_Output>;
  position_X: () => Promise<Float>;
  position_Y: () => Promise<Float>;
  order: () => Promise<Int>;
  project: <T = projectPromise>() => T;
  parent: <T = blockPromise>() => T;
  type: <T = block_typePromise>() => T;
}

export interface blockSubscription
  extends Promise<AsyncIterator<block>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  position_X: () => Promise<AsyncIterator<Float>>;
  position_Y: () => Promise<AsyncIterator<Float>>;
  order: () => Promise<AsyncIterator<Int>>;
  project: <T = projectSubscription>() => T;
  parent: <T = blockSubscription>() => T;
  type: <T = block_typeSubscription>() => T;
}

export interface blockNullablePromise
  extends Promise<block | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  position_X: () => Promise<Float>;
  position_Y: () => Promise<Float>;
  order: () => Promise<Int>;
  project: <T = projectPromise>() => T;
  parent: <T = blockPromise>() => T;
  type: <T = block_typePromise>() => T;
}

export interface projectSubscriptionPayload {
  mutation: MutationType;
  node: project;
  updatedFields: String[];
  previousValues: projectPreviousValues;
}

export interface projectSubscriptionPayloadPromise
  extends Promise<projectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = projectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = projectPreviousValuesPromise>() => T;
}

export interface projectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<projectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = projectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = projectPreviousValuesSubscription>() => T;
}

export interface project_authSubscriptionPayload {
  mutation: MutationType;
  node: project_auth;
  updatedFields: String[];
  previousValues: project_authPreviousValues;
}

export interface project_authSubscriptionPayloadPromise
  extends Promise<project_authSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = project_authPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = project_authPreviousValuesPromise>() => T;
}

export interface project_authSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<project_authSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = project_authSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = project_authPreviousValuesSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Aggregateproject_auth {
  count: Int;
}

export interface Aggregateproject_authPromise
  extends Promise<Aggregateproject_auth>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface Aggregateproject_authSubscription
  extends Promise<AsyncIterator<Aggregateproject_auth>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface project_authConnection {
  pageInfo: PageInfo;
  edges: project_authEdge[];
}

export interface project_authConnectionPromise
  extends Promise<project_authConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<project_authEdge>>() => T;
  aggregate: <T = Aggregateproject_authPromise>() => T;
}

export interface project_authConnectionSubscription
  extends Promise<AsyncIterator<project_authConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<project_authEdgeSubscription>>>() => T;
  aggregate: <T = Aggregateproject_authSubscription>() => T;
}

export interface projectPreviousValues {
  id: ID_Output;
  title: String;
  description: String;
  like: Int;
  private: Boolean;
}

export interface projectPreviousValuesPromise
  extends Promise<projectPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  like: () => Promise<Int>;
  private: () => Promise<Boolean>;
}

export interface projectPreviousValuesSubscription
  extends Promise<AsyncIterator<projectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  like: () => Promise<AsyncIterator<Int>>;
  private: () => Promise<AsyncIterator<Boolean>>;
}

export interface projectEdge {
  node: project;
  cursor: String;
}

export interface projectEdgePromise extends Promise<projectEdge>, Fragmentable {
  node: <T = projectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface projectEdgeSubscription
  extends Promise<AsyncIterator<projectEdge>>,
    Fragmentable {
  node: <T = projectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface Aggregateblock_type {
  count: Int;
}

export interface Aggregateblock_typePromise
  extends Promise<Aggregateblock_type>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface Aggregateblock_typeSubscription
  extends Promise<AsyncIterator<Aggregateblock_type>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  picture: String;
  email: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  picture: () => Promise<String>;
  email: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  picture: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface block_typeConnection {
  pageInfo: PageInfo;
  edges: block_typeEdge[];
}

export interface block_typeConnectionPromise
  extends Promise<block_typeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<block_typeEdge>>() => T;
  aggregate: <T = Aggregateblock_typePromise>() => T;
}

export interface block_typeConnectionSubscription
  extends Promise<AsyncIterator<block_typeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<block_typeEdgeSubscription>>>() => T;
  aggregate: <T = Aggregateblock_typeSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface block_categoryEdge {
  node: block_category;
  cursor: String;
}

export interface block_categoryEdgePromise
  extends Promise<block_categoryEdge>,
    Fragmentable {
  node: <T = block_categoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface block_categoryEdgeSubscription
  extends Promise<AsyncIterator<block_categoryEdge>>,
    Fragmentable {
  node: <T = block_categorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface blockSubscriptionPayload {
  mutation: MutationType;
  node: block;
  updatedFields: String[];
  previousValues: blockPreviousValues;
}

export interface blockSubscriptionPayloadPromise
  extends Promise<blockSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = blockPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = blockPreviousValuesPromise>() => T;
}

export interface blockSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<blockSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = blockSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = blockPreviousValuesSubscription>() => T;
}

export interface User {
  id: ID_Output;
  name: String;
  picture: String;
  email: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  picture: () => Promise<String>;
  email: () => Promise<String>;
  projects: <T = FragmentableArray<project>>(args?: {
    where?: projectWhereInput;
    orderBy?: projectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  authes: <T = FragmentableArray<project_auth>>(args?: {
    where?: project_authWhereInput;
    orderBy?: project_authOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  picture: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  projects: <T = Promise<AsyncIterator<projectSubscription>>>(args?: {
    where?: projectWhereInput;
    orderBy?: projectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  authes: <T = Promise<AsyncIterator<project_authSubscription>>>(args?: {
    where?: project_authWhereInput;
    orderBy?: project_authOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  picture: () => Promise<String>;
  email: () => Promise<String>;
  projects: <T = FragmentableArray<project>>(args?: {
    where?: projectWhereInput;
    orderBy?: projectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  authes: <T = FragmentableArray<project_auth>>(args?: {
    where?: project_authWhereInput;
    orderBy?: project_authOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface blockPreviousValues {
  id: ID_Output;
  position_X?: Float;
  position_Y?: Float;
  order: Int;
}

export interface blockPreviousValuesPromise
  extends Promise<blockPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  position_X: () => Promise<Float>;
  position_Y: () => Promise<Float>;
  order: () => Promise<Int>;
}

export interface blockPreviousValuesSubscription
  extends Promise<AsyncIterator<blockPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  position_X: () => Promise<AsyncIterator<Float>>;
  position_Y: () => Promise<AsyncIterator<Float>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface Aggregateproject {
  count: Int;
}

export interface AggregateprojectPromise
  extends Promise<Aggregateproject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateprojectSubscription
  extends Promise<AsyncIterator<Aggregateproject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface block_categorySubscriptionPayload {
  mutation: MutationType;
  node: block_category;
  updatedFields: String[];
  previousValues: block_categoryPreviousValues;
}

export interface block_categorySubscriptionPayloadPromise
  extends Promise<block_categorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = block_categoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = block_categoryPreviousValuesPromise>() => T;
}

export interface block_categorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<block_categorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = block_categorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = block_categoryPreviousValuesSubscription>() => T;
}

export interface block_typeEdge {
  node: block_type;
  cursor: String;
}

export interface block_typeEdgePromise
  extends Promise<block_typeEdge>,
    Fragmentable {
  node: <T = block_typePromise>() => T;
  cursor: () => Promise<String>;
}

export interface block_typeEdgeSubscription
  extends Promise<AsyncIterator<block_typeEdge>>,
    Fragmentable {
  node: <T = block_typeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface block_categoryConnection {
  pageInfo: PageInfo;
  edges: block_categoryEdge[];
}

export interface block_categoryConnectionPromise
  extends Promise<block_categoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<block_categoryEdge>>() => T;
  aggregate: <T = Aggregateblock_categoryPromise>() => T;
}

export interface block_categoryConnectionSubscription
  extends Promise<AsyncIterator<block_categoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<block_categoryEdgeSubscription>>>() => T;
  aggregate: <T = Aggregateblock_categorySubscription>() => T;
}

export interface block_typePreviousValues {
  id: ID_Output;
  name?: String;
  shape?: String;
  content?: String;
}

export interface block_typePreviousValuesPromise
  extends Promise<block_typePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  shape: () => Promise<String>;
  content: () => Promise<String>;
}

export interface block_typePreviousValuesSubscription
  extends Promise<AsyncIterator<block_typePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  shape: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
}

export interface block_typeSubscriptionPayload {
  mutation: MutationType;
  node: block_type;
  updatedFields: String[];
  previousValues: block_typePreviousValues;
}

export interface block_typeSubscriptionPayloadPromise
  extends Promise<block_typeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = block_typePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = block_typePreviousValuesPromise>() => T;
}

export interface block_typeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<block_typeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = block_typeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = block_typePreviousValuesSubscription>() => T;
}

export interface project_auth {
  id: ID_Output;
}

export interface project_authPromise
  extends Promise<project_auth>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  project: <T = projectPromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface project_authSubscription
  extends Promise<AsyncIterator<project_auth>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  project: <T = projectSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface project_authNullablePromise
  extends Promise<project_auth | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  project: <T = projectPromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface block_categoryPreviousValues {
  id: ID_Output;
  text?: String;
  color?: String;
}

export interface block_categoryPreviousValuesPromise
  extends Promise<block_categoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  color: () => Promise<String>;
}

export interface block_categoryPreviousValuesSubscription
  extends Promise<AsyncIterator<block_categoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  color: () => Promise<AsyncIterator<String>>;
}

export interface Aggregateblock {
  count: Int;
}

export interface AggregateblockPromise
  extends Promise<Aggregateblock>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateblockSubscription
  extends Promise<AsyncIterator<Aggregateblock>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Aggregateblock_category {
  count: Int;
}

export interface Aggregateblock_categoryPromise
  extends Promise<Aggregateblock_category>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface Aggregateblock_categorySubscription
  extends Promise<AsyncIterator<Aggregateblock_category>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface projectConnection {
  pageInfo: PageInfo;
  edges: projectEdge[];
}

export interface projectConnectionPromise
  extends Promise<projectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<projectEdge>>() => T;
  aggregate: <T = AggregateprojectPromise>() => T;
}

export interface projectConnectionSubscription
  extends Promise<AsyncIterator<projectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<projectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateprojectSubscription>() => T;
}

export interface project_authEdge {
  node: project_auth;
  cursor: String;
}

export interface project_authEdgePromise
  extends Promise<project_authEdge>,
    Fragmentable {
  node: <T = project_authPromise>() => T;
  cursor: () => Promise<String>;
}

export interface project_authEdgeSubscription
  extends Promise<AsyncIterator<project_authEdge>>,
    Fragmentable {
  node: <T = project_authSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "project",
    embedded: false
  },
  {
    name: "project_auth",
    embedded: false
  },
  {
    name: "block",
    embedded: false
  },
  {
    name: "block_category",
    embedded: false
  },
  {
    name: "block_type",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
